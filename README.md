# spring-boot-checkout
## Business details 
This project was implemented for an ecommerce site to allow checkout management. The operations implemented are:

* Create a new checkout basket
* Add a product to a basket
* Get the total amount in a basket
* Remove the basket

The products that the site currently offers are pens, tshirts and mugs.

## Technical details
### Starting the app
1) Install Docker
2) Clone this repo
3) Build with gradle: ```./gradlew build```
4) Create jar file for the image: ```mkdir -p build/dependency && (cd build/dependency; jar -xf ../libs/*.jar)```
4) Build the image: ```docker build --build-arg DEPENDENCY=build/dependency -t ecomm/checkout-docker .```
5) Run the image: ```docker run -p 8080:8080 ecomm/checkout-docker```

### Stack
This repository contains a microservice needed to perform operations related to a checkout basket. The technical stack is:
* Docker: used to containerize the app
* Gradle: used to automate the build
* Spring boot: main backend framework that allows to publish endpoints and to use Dependency injection.
* Database management: in-memory using maps. Interfaces have been used to allow swapping current in-memory implementations with a real database. Since we are using spring boot, spring data patterns have been followed so swapping to the real thing can be done painlessly.
* CI: Travis and aws has been configured. On every pull request, code is built and tests are ran to ensure that the product is healthy and as much bugs as possible are caught on time.

### Implemented rest endpoints
```POST /basket```: creates a basket object. Returns status code 201, and the created basket object (including autogenerated ID).

```DELETE /basket/<basketId>```: deletes the basket object to which the basket id belongs to. Returns 204 (no content).

```POST /basket/<basketId>/products```: adds a product to the basket. Returns status code 200, and the basket object including the product added.

```GET /basket/<basketId>/total```: returns the amount to be paid on checkout for the basket to which the basket id belongs to. The total already deduces any eligible discounts. It is formated for the EUR currency.

### Project structure
The project is structured in 3 layers:
* Controller layer: classes that handle logic related to parsing requests from clients, validating them, building responses and getting them to the client. This layer should not contain business logic.
* Service layer: classes that are responsible for executing business logic. These are used by the controller layer, and some of them have a dependency with the repository layer.
* Data/Repository layer: classes thar are responsible for persisting data, and getting data from persistence. These are used by the service layer to save data to DB, and to retrieve data from DB.

We use the dependency injection pattern to configure dependencies between the different components that are part of the app.

The models package has the different entities that are to model our business:
* Basket
* BasketItem
* Product
* Sale

Due to business constraints, the repository layer is not implemented using a real database, but using in memory storage instead. For this we use Maps, specifically the ConcurrentHashMap implementation to ensure thread safety. However, al repository classes are implemented using interfaces, so when the repository implementations are changed to use a real database as long as the interfaces are honoured changes will be isolated to the repository implementations, leaving the business logic classes unchanged.

Part of the business logic is the Sales "framework". It was implemented using the strategy pattern so new sale calculators could be added easily. See the scaling the app section below for more details.

#### Discounts - Sequence

![Discounts sequence](https://user-images.githubusercontent.com/10438941/86717378-81e0a800-bff8-11ea-886b-869f92594291.png)

### Tests
All classes include unit tests. These focus on the components on isolation, using Mockito to stub dependencies and focusing on the classes at test, doing assertions on results and verifying mocks executions.

Integration tests are included too. All implemented endpoints are tested in the BasketControllerIntegrationTest class. Tests on this class start a web server and send requests to the different endpoints, simulating real scenarios and doing assertions on the Http responses.  

### Scaling the app
#### Database
Swapping from the in-memory Database included on this project to a real database is pretty simple. You just need to change the RepositoryImpl classes to use your new database implementation. The suggested path to follow, since the project is done using spring-boot, is to use Spring Data. Spring Data has a convenient CrudRepository interface that you can extend on your Repository interfaces and includes basic crud operations automatically.

#### Adding new discount types
Sales code has been structured using the strategy pattern, which allows to add a new discount type in a few easy steps:

1) Add a new implementation of SalesCalculator that contains the logic to calculate discounts using a Sales object and a BasketItem in a way that meets your new discount type business logic.
2) Add a new SaleType enum value to represent your new Sale discount type
3) Add a new case to the SalesFactory so the new discount type will be instantiated on presence of the new discount type.

The only thing you need to do after is create Sales records with the new SaleType and referencing specific product types, so when a basket item is eligible by the new sale type it will match and calculate the proper discount.

#### Adding discounts using existing discount types, affecting new product types/codes
Reusing existing discounts calculation for product types other than the ones currently listed is pretty easy. You just need to create new Sales object that have a SaleType referencing the type of sale you want to offer, and a ProductType for the product type you want to be affected by the new sale.

Some upgrades that could be implemented:
* Add a productId to sales so we can release sales for a specific product
* Add startDate and expirationDate to sales so they can go live and sunset automatically on specific moments of time (ex.: christmas sales, etc).
